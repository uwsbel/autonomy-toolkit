:py:mod:`autonomy_toolkit.containers.docker_client`
===================================================

.. py:module:: autonomy_toolkit.containers.docker_client

.. autoapi-nested-parse::

   Helpful utilities for interacting with docker.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   autonomy_toolkit.containers.docker_client.DockerClient




.. py:exception:: ContainerException(message: Any, stdout: str = None, stderr: str = None)

   Bases: :py:obj:`Exception`

   Exception class that is used by the :class:`ContainerClient` when an error occurs

   :Parameters: * **message** (*Any*) -- The message to be stored in the base class Exception
                * **stdout** (*str*) -- The stdout from the command
                * **stderr** (*str*) -- The stderr from the command


.. py:class:: DockerClient(config: autonomy_toolkit.utils.atk_config.ATKConfig, *, dry_run: bool = False, opts: List[str] = [], args: List[str] = [])

   Client interface for interacting with docker compose orchestration.

   :Parameters: * **config** (*ATKConfig*) -- The ATK configuration object.
                * **dry_run** (*bool*) -- Whether to actually run the commands or just print them. Use DEBUG logging level to see the commands.
                * **opts** (*List[str]*) -- Options to pass to the ``docker compose`` command.
                * **args** (*List[str]*) -- Arguments to pass to the ``docker compose <command>`` command.

   .. py:method:: down() -> bool

      Bring down the containers.

      :returns: *bool* -- Whether the command succeeded.


   .. py:method:: build() -> bool

      Build the images.

      :returns: *bool* -- Whether the command succeeded.


   .. py:method:: up() -> bool

      Bring up the containers.

      :returns: *bool* -- Whether the command succeeded.


   .. py:method:: run() -> bool

      Run a command in a container.

      :returns: *bool* -- Whether the command succeeded.


   .. py:method:: attach() -> bool

      Attach to a container.

      NOTE: We assume a shell session is desired.

      This is somewhat difficult, as we don't know the default shell of the user in the container. We therefore have to determine this at runtime with a pretty nasty command.

      :returns: *bool* -- Whether the command succeeded.


   .. py:method:: run_cmd(cmd, *args, without_ots: bool = False, **kwargs) -> bool

      Run a command using the system wide ``compose`` command

      Additional positional args (``*args``) will be passed as command arguments when running the command.
      Named arguments will be passed to :meth:`subprocess.run`
      (`see their docs <https://docs.python.org/3/library/subprocess.html#subprocess.run>`_).

      :Parameters: **cmd** (*str*) -- The command to run.

      :returns: *Bool* -- Whether the command succeeded.


   .. py:method:: run_compose_cmd(*args, **kwargs) -> bool

      Run a docker compose command.



